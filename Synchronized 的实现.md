这里有一个关于synchronized关键字内部实现的[讨论](https://stackoverflow.com/questions/25949145/synchronized-keyword-internal-implementation)，有点意思。
## synchronized同步锁的实现
java中的synchronized关键字用来处理java中多线程同步的问题，既可以用它声明一个被synchronized关键字标注的代码块，也可以用它直接标注静态方法或实例方法。具体对于该关键字如何使用，我们另行讨论，或许你可以参考下这篇[文章](https://www.journaldev.com/31514/java-synchronized-keyword-method-block)。这篇文章的目的主要介绍一下该关键字是如何实现的。

#### 两个指令
##### monitorenter 与 monitorexit
首先编译下面的java代码，然后对生成的.class文件，执行指令`javap -verbose Test.class`。产生如下图所示的字节码，能够看到一个`monitorenter`对应两个`monitorexit`指令。这里的两个monitorexit指令，是为了保证在任何状况下，锁都能够正常退出。所以实际上`monitorenter`与`monitorexit`是一对一的关系。这两个指令各自会消耗操作数栈上的一个引用类型的元素，作为加解锁的锁对象。也就是下面代码中的lock对象。

    public class Test {
      public void test(Object lock) {
            synchronized (lock) {
                lock.hashCode();
            }
        }
    }
![](https://github.com/WalkingNL/Pics/blob/master/synchronized.jpg)

上面的代码中，用synchronized关键字标注的是对象。但如果用它标记方法时，见下面的代码。编译再执行javap指令，生成的字节码文件如下图。访问标记与上图相比有两点差别。第一，访问标记变了；第二，虚指令里无`monitorenter`与`monitorexit`了。一个一个来说，能够看到下图中访问标记(flags)后面多了ACC_SYNCHRONIZED。有了这个标记，意思是在进入到test()方法中时，java虚拟机进行monitorenter操作。在退出时，一定能保证执行monitorexit操作。只不过这种加锁的方式下，monitorenter与monitorexit操作对应的锁对象是隐式的。因为这里test()是实例方法，所以锁对象自然就是this；如果改成静态方法，锁对象就是类的Class实例。
    
    public class Test {
      public synchronized void test(Object lock) {
            lock.hashCode();
        }
    }
    
![](https://github.com/WalkingNL/Pics/blob/master/synchronized_mark.jpg)

#### 锁的类别

##### 重量级锁
最基础、最原始的锁。这种方式的加锁非常笨重，得依靠操作系统来完成。需要系统调用，开销非常大。对于不同的操作系统，调用的接口不同。例如，在类似许多诸如Linux这样的平台上，是通过调用pthread来实现的。如果频繁进行`阻塞`与`唤醒`这种昂贵的过程，代价无疑是巨大的。基于此，在重量级锁的情形下，为了能在一定程度上减少对线程的`阻塞`和`唤醒`，引入了一定的优化措施，如线程自旋。
###### 自旋状态
线程会在以下两种情形下进入自旋的状态，从而尽量避免被阻塞。进入自旋状态后，线程在处理器上空跑，并不断的轮询锁是否被释放。如果锁被释放了，线程便可以很快取得锁。
  * 进入阻塞状态之前
  * 被唤醒后得不到锁的时候

这自然是好事，但也是有代价的。避免线程进入阻塞，意味着线程依然占有着CPU资源，只不过是在空跑无用的指令。如果锁始终没有释放，处于自旋状态的线程便长时间自旋，无疑在浪费处理器资源。所以这里需要至少解决两个基本问题。
1. 自旋的时间。如果一直轮询，是没有好处的。
2. 什么时候进入自旋，而不是阻塞。

之前，有看到**郑雨迪**老师以红绿灯举了一个例子，以下引述一下。
> Java线程的阻塞相当于熄火停车，而自旋状态相当于怠速停车。如果红绿灯的等待时间非常长，那么熄火停车相对省油一些；如果红绿灯的等待时间非常短，比如说在synchronized代码里只做了一个整型加法，那么在短时间内，锁肯定能被释放出来，所以怠速停车更加合适。

###### 进入自旋的时机
上面的引例很生动，非常简明的道出了自旋存在的必要性，以及在怎样的情况下，应该先让线程自旋，而不是阻塞。不过还有一个问题需要解决，就是人选择怠速还是熄火，是根据红绿灯剩余时间的多少来决定。但机器没有这样的参考，基于此，Java虚拟机给出了一个自适应的方案，大意是根据经验判断。就是以往自选等待时，是否能够获得锁。通过这样的方式，动态调整自旋的时间。

###### 锁竞争的公平性讨论
处于自旋状态的线程与进入阻塞状态的线程，在最终谁能最先获得锁的问题上，存在对立。自旋引入的目的，本质上是为了进行锁优化，但为锁的公平性竞争带来了副作用。这里的不公平性体现在时间上，如果一个锁被释放，只要被自旋状态的锁轮询发现，就能直接获得。而被阻塞的线程，至少存在一个被唤醒的过程，而唤醒线程涉及从内核态到用户态的转变，这是一个缓慢的过程。

这个话题，待续。。。。。。

##### 轻量级锁
什么是轻量级锁，为什么需要轻量级锁。

锁就是锁，哪儿有什么轻重之分。这里只是针对不同的场景，对锁的另一种叫法。上面的重量级锁，一直说多个线程在竞争锁，然而有时候，当这种竞争不存在的时候，就比如同一时刻，只有某一个线程来请求锁，这时，锁的竞争就不存在了。既然不存在了，也就用不着对竞争不到锁的线程进行阻塞唤醒了。所以说呢，轻量级锁只是对锁本身的另一种叫法，我们要真正区分的只是场景，即什么时候竞争关系存在，什么时候不存在。

java虚拟机是如何区分各种不同叫法的锁的呢？看一张图吧(图片取自[这里](https://blog.csdn.net/zc19921215/article/details/84780335))。

![](https://github.com/WalkingNL/Pics/blob/master/synchronized_0.png)

对象头标记字段的最后两位用来表示对象的锁状态。能够看到00就表示轻量级锁，10表示重量级锁。
###### 原理介绍
在进行加锁时，首先，Java虚拟机会判断是否已是重量级锁。如果不是，虚拟机会在当前线程的Frame中**划**出一块空间，用作该锁的锁记录，然后把锁对象的标记字段**复制到**锁记录中。接着利用CAS原子操作替换锁对象的标记字段。【注：如果不知道CAS可以参考我写的无锁的简单实现那篇[文章](https://github.com/WalkingNL/C-CPP/blob/master/LockFree.md)】

这里所述CAS具体怎样的一个执行过程呢？假设对象标记字段的**最后两位**为XY，java虚拟机会拿期望的值01与之作比较，如果是，就替换为刚才分配的锁记录的地址(因为内存对齐的缘故，最后两位是00)。这个时候，表示线程成功取得锁。如果不是，存在以下两种可能(其实本质就是有线程正持有该锁，要么是就是当前线程，要么是其它线程)。因为01表示的是无锁，如果不是01，说明已经有线程持有该锁。
1. 重复获取同一把锁。这种情况，java虚拟机会清零锁记录，表示该锁记录被重复获取。
2. 其它线程持有该锁。这种情况，就说明有了竞争的问题，锁将会被膨胀为重量级锁，伴随着对当前线程的阻塞。

上述为加锁，如果解锁时，当前记录的值时0，表示重复进入同一把锁，直接返回。否则，有Java虚拟机再次进行CAS操作。对比锁对象标记字段的值是否为当前记录的地址。如果是，就替换为记录里的值。这样，就成功释放了锁。

##### 偏向锁
什么又是偏向锁呢？好吧，还是说场景好了！它针对的情况是自始至终，只有一个线程进行锁请求。如果锁对象支持偏向锁，虚拟机利用CAS操作，把当前线程的地址记录在锁对象的标记字段中，并将标记字段的最后三位置为101。之后，只要有线程请求锁，虚拟机需要判断以下三种情况：
1. 最后三位是否为101；
2. 是否包含当前线程地址；
3. epoch值是否和锁对象的类的epoch值相同。

那epoch是个什么东西呢？epoch值和之后偏向锁的撤销有关。所以，先看一下偏向锁的撤销。
###### 偏向锁的撤销
当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时，虚拟机就得撤销偏向锁（注意，撤销偏向锁，并非锁的释放）。撤销的过程要求偏向锁的线程达到**安全点**，再把偏向锁**替换**成轻量级锁。

如果一类锁对象的总撤销次数超过一个阈值(默认应该是20，-XX:BiasedLockingBulkRebiasThreshold)，虚拟机认为该类的偏向锁失效。做法就是再类中维护一个epoch值，可以认为是第几代偏向锁。当设置偏向锁时，虚拟机需要将该epoch值复制到锁对象的标记字段中。在虚拟机认定这个类的偏向锁失效时，虚拟机就将该类中的epoch值加1，表示之前那一代的偏向锁已经失效。对于新设置的偏向锁需要复制新的epoch值。为确保当前持有偏向锁且已经持有锁的线程不会丢锁，虚拟机需遍历所有线程的Java栈，找出该类已加锁的实例，并将他们标记字段中的epoch值加1。这个过程须所有线程处于安全点状态。当总的撤销数量超过另一个阈值，虚拟机认定此类不再适合偏向锁。这个时候，虚拟机就撤销该类实例的偏向锁，并在之后对该类加锁时，在这种场景下，直接置为轻量级锁。

##### 总结
上面介绍了java synchronized关键字的底层一些实现过程。虽然涉及到了三种类别的锁，但实际上，只是一种，即重量级锁。轻量级锁以及偏向锁更多的是在不同场景下，对重量级锁的优化。原因其实很简单，多线程中，公共资源得加锁，以保证互斥的访问。但如果一些时候，不存在竞争的问题，就像偏向锁和轻量级锁针对的场景。既然不竞争，那么依然按照重量级锁的方式加锁，自然是对资源的浪费。

但问题在于，常常为了优化性能，资源节约，就会增加复杂度。就如同synchronized关键字的实现那样，引入了不同的锁，就得考虑每一种锁包含的情况，以及如何向其他锁转换，如下图。而且每一种又有它自己的特殊情况，如偏向锁判别方式，失效次数等等。学习这些东西带来的收获是巨大的，如果你在工作中，锁优化除了减少锁的粒度、锁的数量，以及在业务层面考虑，通过减少业务逻辑，降低锁的持有时间之外，还有哪些关于锁的优化方式。学习诸如synchronized关键字的实现过程，不仅可以学习新的东西，还可以拓宽思路，引领学习者从新的方向考虑。

![](https://github.com/WalkingNL/Pics/blob/master/lock.jpg)

关于synchronized关键字的实现，后续还有很多的内容会补充进来。不过这个过程绝对快不了，但也不会太慢。
